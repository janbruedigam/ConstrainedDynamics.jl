var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/code/#Mechanism-from-Code","page":"From Code","title":"Mechanism from Code","text":"","category":"section"},{"location":"gettingstarted/code/","page":"From Code","title":"From Code","text":"Besides parsing a URDF file, you can also code up your mechanism.","category":"page"},{"location":"gettingstarted/code/","page":"From Code","title":"From Code","text":"## Dynamics simulation\nusing ConstrainedDynamics\n\n# Origin\norigin = Origin{Float64}()\n\n# Links\nlink1 = Box(0.1, 0.1, 1, 1) # Box with length-x, length-y, length-z, and mass\nlink2 = Box(0.1, 0.1, 1, 1)\n\nlinks = [link1;link2]\n\n# Constraints\naxis = [1;0;0] # rotation axis\nconnection1 = [0;0;0.5] # connection points in body frame\nconnection2 = [0;0;-0.5]\njoint01 = EqualityConstraint(Revolute(origin, link1, axis; p2=connection1))\njoint12 = EqualityConstraint(Revolute(link1, link2, axis; p1=connection2, p2=connection1))\n\nconstraints = [joint01;joint12]\n\n# Mechanism\nmech = Mechanism(origin, links, constraints)\n\n# Set feasible initial configuration\nsetPosition!(origin, link1, p2 = connection1) # set link1 relative to origin\nsetPosition!(link1, link2, p1 = connection2, p2 = connection1, Δq = UnitQuaternion(RotX(pi/2))) # set link2 relative to link1 with an offset angle of pi/2\n\n# Simulate\nstorage = simulate!(mech, 10, record = true) # simulate mech for 10 seconds and record the result (will be stored in storage)\n\n## Visualization\nusing ConstrainedDynamicsVis \n\nvisualize(mech, storage) # visualize mech with the data in storage.\n ","category":"page"},{"location":"library/mechanism/#Mechanism","page":"Mechanism","title":"Mechanism","text":"","category":"section"},{"location":"library/mechanism/#Mechanism-2","page":"Mechanism","title":"Mechanism","text":"","category":"section"},{"location":"library/mechanism/","page":"Mechanism","title":"Mechanism","text":"Mechanism","category":"page"},{"location":"library/mechanism/#ConstrainedDynamics.Mechanism","page":"Mechanism","title":"ConstrainedDynamics.Mechanism","text":"mutable struct Mechanism{T, Nn, Nb, Ne, Ni} <: ConstrainedDynamics.AbstractMechanism{T, Nn, Nb, Ne, Ni}\n\nA Mechanism contains the Origin, Bodys, and EqualityConstraints of a system and can be used for simulation.\n\nImportant attributes\n\norigin:        The origin of a mechanism.\nbodies:        The bodies of a mechanism (Dict).\neqconstraints: The equality constraints (joints) of a mechanism (Dict).\nΔt:            The time step of the mechanism.\ng:             The gravitational acceleration in z-direction.\n\nConstuctors\n\nMechanism(origin, bodies; Δt, g)\nMechanism(origin, bodies, eqcs; Δt, g)\nMechanism(urdf_filename; floating, Δt, g)\n\n\n\n\n\n","category":"type"},{"location":"library/constraint/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"library/constraint/#EqualityConstraint","page":"Constraints","title":"EqualityConstraint","text":"","category":"section"},{"location":"library/constraint/","page":"Constraints","title":"Constraints","text":"EqualityConstraint","category":"page"},{"location":"library/constraint/#ConstrainedDynamics.EqualityConstraint","page":"Constraints","title":"ConstrainedDynamics.EqualityConstraint","text":"mutable struct EqualityConstraint{T, N, Nc, Cs} <: ConstrainedDynamics.AbstractConstraint{T, N}\n\nAn EqualityConstraint is a component of a Mechanism and is used to describe the kinematic relation between two or more Bodys.  Typically, an EqualityConstraint should not be created directly. Use the joint prototypes instead, for example: \n\nEqualityConstraint(Revolute(body1, body2, rotation_axis)).\n\nImportant attributes\n\nid:       The unique ID of a constraint. Assigned when added to a Mechanism.  \nname:     The name of a constraint. The name is taken from a URDF or can be assigned by the user.\nparentid: The ID of the parent body.  \nchildids: The IDs of the child bodies.  \n\n\n\n\n\n","category":"type"},{"location":"library/constraint/#Joint-Prototypes","page":"Constraints","title":"Joint Prototypes","text":"","category":"section"},{"location":"library/constraint/","page":"Constraints","title":"Constraints","text":"The functions below can be used to create joints between two bodies. Note that body1 can also be the origin. The following arguments are available for most joints:","category":"page"},{"location":"library/constraint/","page":"Constraints","title":"Constraints","text":"axis:     The rotation axis or plane axis.\np1:       The joint connection point for body1 in body1's frame\np2:       The joint connection point for body2 in body2's frame\nqoffsett: The orientation offset of body2 relative to body1","category":"page"},{"location":"library/constraint/","page":"Constraints","title":"Constraints","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"prototypes.jl\"]","category":"page"},{"location":"library/constraint/#ConstrainedDynamics.Cylindrical-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Cylindrical","text":"Cylindrical(body1, body2, axis; p1, p2, qoffset, spring, damper)\n\nA cylindrical joint between two bodies.\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.CylindricalFree-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.CylindricalFree","text":"CylindricalFree(body1, body2, axis; p1, p2, spring, damper)\n\nA cylindrical joint between two bodies with unconstrained orientation (point-on-line).\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Fixed-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Fixed","text":"Fixed(body1::AbstractBody, body2; p1, p2, qoffset)\n\nA fixed connection between two bodies.\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.FixedOrientation-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.FixedOrientation","text":"FixedOrientation(body1, body2; qoffset, spring, damper)\n\nFixed orientation between two bodies (chicken's head).\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Floating-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Floating","text":"Floating(body1, body2; spring, damper)\n\nAn unconstrained connection between two bodies (connection between floating base and origin).\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Planar-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Planar","text":"Planar(body1, body2, axis; p1, p2, qoffset, spring, damper)\n\nA planar joint between two bodies.\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.PlanarAxis-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.PlanarAxis","text":"PlanarAxis(body1, body2, axis; p1, p2, qoffset, spring, damper)\n\nA planar joint between two bodies with a rotation axis perpendicular to the plane (turtle bot).\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.PlanarFree-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.PlanarFree","text":"PlanarFree(body1, body2, axis; p1, p2, spring, damper)\n\nA planar joint between two bodies with unconstrained orientation.\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Prismatic-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Prismatic","text":"Prismatic(body1, body2, axis; p1, p2, qoffset, spring, damper)\n\nA prismatic joint between two bodies.\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Revolute-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Revolute","text":"Revolute(body1, body2, axis; p1, p2, qoffset, spring, damper)\n\nA revolute joint between two bodies (pin, continuous, hinge joint).\n\n\n\n\n\n","category":"method"},{"location":"library/constraint/#ConstrainedDynamics.Spherical-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractBody{T}, Any}} where T","page":"Constraints","title":"ConstrainedDynamics.Spherical","text":"Spherical(body1, body2; p1, p2, spring, damper)\n\nA spherical joint between two bodies (ball-and-socket joint).\n\n\n\n\n\n","category":"method"},{"location":"gettingstarted/urdf/#Mechanism-from-URDF","page":"From URDF","title":"Mechanism from URDF","text":"","category":"section"},{"location":"gettingstarted/urdf/","page":"From URDF","title":"From URDF","text":"The easiest way to run a simulation is to parse a URDF file.","category":"page"},{"location":"gettingstarted/urdf/","page":"From URDF","title":"From URDF","text":"## Dynamics simulation\nusing ConstrainedDynamics\n\npath = \"path_to_file/doublependulum.urdf\"\nmech = Mechanism(path; Δt = 0.01)\nstorage = simulate!(mech, 10, record = true) # simulate mech for 10 seconds and record the result (will be stored in storage)\n\n## Visualization\nusing ConstrainedDynamicsVis \n\nvisualize(mech, storage) # visualize mech with the data in storage.\n ","category":"page"},{"location":"library/interface/#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"library/interface/#Initialization","page":"Interface","title":"Initialization","text":"","category":"section"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"The unused kwargs of initialization functions are set to zero.","category":"page"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"initialize.jl\"]","category":"page"},{"location":"library/interface/#ConstrainedDynamics.setPosition!-Tuple{Body, Body}","page":"Interface","title":"ConstrainedDynamics.setPosition!","text":"setPosition!(body1, body2; p1, p2, Δx, Δq)\n\nSet the position and orientation of body2 relative to body1 at the connection points p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setPosition!-Tuple{Body}","page":"Interface","title":"ConstrainedDynamics.setPosition!","text":"setPosition!(body; x, q)\n\nSet the position and orientation of a body.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setPosition!-Tuple{Origin, Body}","page":"Interface","title":"ConstrainedDynamics.setPosition!","text":"setPosition!(origin, body2; p1, p2, Δx, Δq)\n\nSet the position and orientation of body2 relative to the origin at the connection points p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setVelocity!-Tuple{Body, Body}","page":"Interface","title":"ConstrainedDynamics.setVelocity!","text":"setVelocity!(body1, body2; p1, p2 Δv, Δω)\n\nSet the translational and angular velocity of body2 relative to body1 at the connection points p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setVelocity!-Tuple{Body}","page":"Interface","title":"ConstrainedDynamics.setVelocity!","text":"setVelocity!(body; v, ω)\n\nSet the translational and angular velocity of a body.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setVelocity!-Tuple{Origin, Body}","page":"Interface","title":"ConstrainedDynamics.setVelocity!","text":"setVelocity!(origin, body2; p1, p2 Δv, Δω)\n\nSet the translational and angular velocity of body2 relative to the origin at the connection points p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#Indexing","page":"Interface","title":"Indexing","text":"","category":"section"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"The following functions can be used to get bodies and constraints from a mechanism.","category":"page"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"mechanism_functions.jl\"]","category":"page"},{"location":"library/interface/#ConstrainedDynamics.getbody-Tuple{Mechanism, Integer}","page":"Interface","title":"ConstrainedDynamics.getbody","text":"getbody!(mechanism, id)\n\nGets the body with ID id from mechanism if it exists. If id = nothing, the origin will be returned.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.getbody-Tuple{Mechanism, String}","page":"Interface","title":"ConstrainedDynamics.getbody","text":"getbody!(mechanism, name)\n\nGets the body with name name from mechanism if it exists.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.getcomponent-Tuple{Mechanism, Integer}","page":"Interface","title":"ConstrainedDynamics.getcomponent","text":"getcomponent!(mechanism, id)\n\nGets the component (body or equality constraint) with ID id from mechanism if it exists.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.getcomponent-Tuple{Mechanism, String}","page":"Interface","title":"ConstrainedDynamics.getcomponent","text":"getcomponent!(mechanism, name)\n\nGets the component (body or equality constraint) with name name from mechanism if it exists.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.geteqconstraint-Tuple{Mechanism, Integer}","page":"Interface","title":"ConstrainedDynamics.geteqconstraint","text":"geteqconstraint!(mechanism, id)\n\nGets the equality constraint with ID id from mechanism if it exists.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.geteqconstraint-Tuple{Mechanism, String}","page":"Interface","title":"ConstrainedDynamics.geteqconstraint","text":"geteqconstraint!(mechanism, name)\n\nGets the equality constraint with name name from mechanism if it exists.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#Minimal-Coordinates","page":"Interface","title":"Minimal Coordinates","text":"","category":"section"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"The state of a mechanism ist stored in maximal coordinates, i.e. the position and orientation of each body. Minimal coordinates (generalized, joint coordinates) can be set and retrived from constraints with the following functions.","category":"page"},{"location":"library/interface/","page":"Interface","title":"Interface","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"equalityconstraint.jl\"]","category":"page"},{"location":"library/interface/#ConstrainedDynamics.minimalCoordinates-Union{Tuple{Nc}, Tuple{N}, Tuple{T}, Tuple{Any, EqualityConstraint{T, N, Nc, Cs} where Cs}} where {T, N, Nc}","page":"Interface","title":"ConstrainedDynamics.minimalCoordinates","text":"minimalCoordinates(mechanism, eqconstraint)\n\nGets the minimal coordinates of joint eqconstraint.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.minimalVelocities-Union{Tuple{Nc}, Tuple{N}, Tuple{T}, Tuple{Any, EqualityConstraint{T, N, Nc, Cs} where Cs}} where {T, N, Nc}","page":"Interface","title":"ConstrainedDynamics.minimalVelocities","text":"minimalVelocities(mechanism, eqconstraint)\n\nGets the minimal coordinate velocities of joint eqconstraint.\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setForce!-Union{Tuple{Nc}, Tuple{N}, Tuple{T}, Tuple{Any, EqualityConstraint{T, N, Nc, Cs} where Cs, AbstractVector{T} where T}} where {T, N, Nc}","page":"Interface","title":"ConstrainedDynamics.setForce!","text":"setForce!(mechanism, eqconstraint, Fτ)\n\nSets the minimal coordinate forces (vector) of joint eqconstraint.\n\nPrismatic joint example:     setVelocity!(mechanism, geteqconstraint(mechanism, jointid), [-1.0])\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setPosition!-Tuple{Any, EqualityConstraint, Any}","page":"Interface","title":"ConstrainedDynamics.setPosition!","text":"setPosition!(mechanism, eqconstraint, xθ)\n\nSets the minimal coordinates (vector) of joint eqconstraint. \n\nRevolute joint example:     setPosition!(mechanism, geteqconstraint(mechanism, \"joint_name\"), [pi/2])\n\n\n\n\n\n","category":"method"},{"location":"library/interface/#ConstrainedDynamics.setVelocity!-Tuple{Any, EqualityConstraint, Any}","page":"Interface","title":"ConstrainedDynamics.setVelocity!","text":"setVelocity!(mechanism, eqconstraint, vω)\n\nSets the minimal coordinate velocities (vector) of joint eqconstraint.\n\nPlanar joint example:     setVelocity!(mechanism, geteqconstraint(mechanism, jointid), [0.5;2.0])\n\n\n\n\n\n","category":"method"},{"location":"library/simulation/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"library/simulation/#Simulation-Methods","page":"Simulation","title":"Simulation Methods","text":"","category":"section"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"simulate.jl\"]","category":"page"},{"location":"library/simulation/#ConstrainedDynamics.simulate!-Union{Tuple{N}, Tuple{T}, Tuple{ConstrainedDynamics.AbstractMechanism, Storage{T, N}, Vararg{Any, N} where N}} where {T, N}","page":"Simulation","title":"ConstrainedDynamics.simulate!","text":"simulate!(mechanism, storage, args..., kwargs)\n\nSimulate a mechanism for the number of time steps specified by storage (see Storage). The time step has been set in mechanism. \n\nThis method can be used to debug potentially faulty (instable) controllers: Even if the simulation fails, the results up to the point of failure are stored in storage and can be analyzed and visualized.\n\nA controller or control function (see Controller) can be passed in with args. If no controller is needed, nothing needs to be passed in.\n\nAvailable kwargs:\n\nrecord:     Specify if the state trajectory should be stored (true) or not (false).\nε:          Solver tolerance.\n\n\n\n\n\n","category":"method"},{"location":"library/simulation/#ConstrainedDynamics.simulate!-Union{Tuple{T}, Tuple{ConstrainedDynamics.AbstractMechanism{T, Nn, Nb, Ne, Ni} where {Nn, Nb, Ne, Ni}, Real, Vararg{Any, N} where N}} where T","page":"Simulation","title":"ConstrainedDynamics.simulate!","text":"simulate!(mechanism, tend, args..., kwargs)\n\nSimulate a mechanism for tend seconds. The time step has been set in mechanism.\n\nA controller or control function (see Controller) can be passed in with args. If no controller is needed, nothing needs to be passed in.\n\nAvailable kwargs:\n\nrecord:     Specify if the state trajectory should be stored (true) or not (false).\nε:          Solver tolerance.\n\n\n\n\n\n","category":"method"},{"location":"library/simulation/#Storage","page":"Simulation","title":"Storage","text":"","category":"section"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"Storage","category":"page"},{"location":"library/simulation/#ConstrainedDynamics.Storage","page":"Simulation","title":"ConstrainedDynamics.Storage","text":"struct Storage{T, N}\n\nA Storage can be used to store simulation results for a Mechanism.\n\nIndexing example:     storage.x[bodyid][timestep_number][2] # returns the y-position of the specified body at the specified time step.\n\nImportant attributes\n\nx: Contains the position for each body and each time step. \nq: Contains the orientation for each body and each time step. \nv: Contains the velocity for each body and each time step.   \nω: Contains the angluar velocity for each body and each time step. \n\nConstructors\n\nStorage{T}(step_range, nbodies)\nStorage(step_range, nbodies)\nStorage{T}(nsteps, nbodies)\nStorage(nsteps, nbodies)\n\n\n\n\n\n","category":"type"},{"location":"library/simulation/#Control-Function-and-Controller","page":"Simulation","title":"Control Function and Controller","text":"","category":"section"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"Users can pass a control function to simulate!. This control function must be of the form","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"control_function(mechanism, timestep)","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"If such a control function is passed to simulate!, at each time step, control_function(mechanism, timestep) will be called.  This way, the user has access to all attributes of the mechanism and the time step.","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"It is also possible to pass in a controller object:","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"Controller","category":"page"},{"location":"library/simulation/#ConstrainedDynamics.Controller","page":"Simulation","title":"ConstrainedDynamics.Controller","text":"abstract type Controller\n\nUsers can create subtypes of Controller to implement controllers.  If such a controller object is passed to simulate!, at each time step, controller.control!(mechanism, controller, timestep) will be called.  This way, the user has access to all attributes of the mechanism, the controller, and the time step. Note that the control function must be called control!.\n\n\n\n\n\n","category":"type"},{"location":"library/simulation/#Visualization","page":"Simulation","title":"Visualization","text":"","category":"section"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"For details, see the ConstrainedDynamicsVis package.","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"Basic visualization can be performed with:","category":"page"},{"location":"library/simulation/","page":"Simulation","title":"Simulation","text":"using ConstrainedDynamicsVis\n\nvisualize(mechanism, storage)","category":"page"},{"location":"#ConstrainedDynamics","page":"Home","title":"ConstrainedDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConstrainedDynamics is a rigid body dynamics package written in Julia. It uses maximal coordinates instead of minimal coordinates to represent the states of a mechanism. This parametrization can be advantageous when simulating structures with additional explicit constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is largely built on StaticArrays and avoids allocations for improved performance. Convenience methods for setting up mechanical structures in maximal or minimal coordinates are provided and URDF parsing is also available. The provided examples should help with getting started with the package. ","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"body.md\",\n  \"constraint.md\",\n  \"mechanism.md\",\n  \"interface.md\",\n  \"simulation.md\"]\nDepth = 2","category":"page"},{"location":"library/body/#Bodies-and-Origin","page":"Bodies and Origin","title":"Bodies and Origin","text":"","category":"section"},{"location":"library/body/#Body-and-Origin","page":"Bodies and Origin","title":"Body and Origin","text":"","category":"section"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Body","category":"page"},{"location":"library/body/#ConstrainedDynamics.Body","page":"Bodies and Origin","title":"ConstrainedDynamics.Body","text":"mutable struct Body{T} <: ConstrainedDynamics.AbstractBody{T}\n\nA Body is a component of a Mechanism.\n\nImportant attributes\n\nid:    The unique ID of a body. Assigned when added to a Mechanism.  \nname:  The name of a body. The name is taken from a URDF or can be assigned by the user.  \nm:     The mass of a body.  \nJ:     The inertia of a body.  \nstate: The state of a body. Contains all position and velocity information (see State).  \nshape: The visualization shape of a body (see Shape).  \n\nConstructors\n\nBody(m, J; name, shape)  \nMesh(path, m, J; scale, kwargs...)  \nBox(x, y, z, m; kwargs...)  \nCylinder(r, h, m; kwargs...)  \nSphere(r, m; kwargs...)  \nPyramid(w, h, m; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Origin","category":"page"},{"location":"library/body/#ConstrainedDynamics.Origin","page":"Bodies and Origin","title":"ConstrainedDynamics.Origin","text":"mutable struct Origin{T} <: ConstrainedDynamics.AbstractBody{T}\n\nThe Origin is the root of a Mechanism.\n\nImportant attributes\n\nid:    The unique ID of the origin. Assigned when added to a Mechanism.  \nname:  The name of the origin. The name is taken from a URDF or can be assigned by the user.  \nshape: The visualization shape of the origin (see Shape).  \n\nConstructors\n\nOrigin(; name, shape)  \nOrigin{Type}(; name, shape)  \nOrigin(body)\n\n\n\n\n\n","category":"type"},{"location":"library/body/#State","page":"Bodies and Origin","title":"State","text":"","category":"section"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"ConstrainedDynamics.State","category":"page"},{"location":"library/body/#ConstrainedDynamics.State","page":"Bodies and Origin","title":"ConstrainedDynamics.State","text":"mutable struct State{T}\n\nThe State contains the position and velocity information of a Body.\n\nImportant attributes\n\nxc: Continuous-time position (vector)\nqc: Continuous-time oritentation (quaternion)\nvc: Continuous-time velocity (vector)\nωc: Continuous-time angular velocity (vector)\nxk: Knot-point positions (vector of vectors)\nqk: Knot-point orientations (vector of vectors)\n\n\n\n\n\n","category":"type"},{"location":"library/body/#Shape","page":"Bodies and Origin","title":"Shape","text":"","category":"section"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"ConstrainedDynamics.Shape","category":"page"},{"location":"library/body/#ConstrainedDynamics.Shape","page":"Bodies and Origin","title":"ConstrainedDynamics.Shape","text":"abstract type Shape{T}\n\nA Shape is used for visualization of a Body. All Shapes have an xoffset and a qoffset parameter to specify the position and orientation offset between the actual Body and the visualized Shape.\n\nImportant attributes\n\nxoffset: The relative position offset (vector) between Body and Shape.  \nqoffset: The relative orientation offset (quaternion) between Body and Shape.\ncolor:   The color of the Shape.\n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Mesh","category":"page"},{"location":"library/body/#ConstrainedDynamics.Mesh","page":"Bodies and Origin","title":"ConstrainedDynamics.Mesh","text":"mutable struct Mesh{T} <: ConstrainedDynamics.Shape{T}\n\nA Mesh can be used to visualize arbitrary geometries.\n\nImportant attributes\n\npath: The path to the geometry file.  \n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Box","category":"page"},{"location":"library/body/#ConstrainedDynamics.Box","page":"Bodies and Origin","title":"ConstrainedDynamics.Box","text":"mutable struct Box{T} <: ConstrainedDynamics.Shape{T}\n\nA Box.\n\nImportant attributes\n\nxyz: The box size in x, y, and z direction (vector).  \n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Cylinder","category":"page"},{"location":"library/body/#ConstrainedDynamics.Cylinder","page":"Bodies and Origin","title":"ConstrainedDynamics.Cylinder","text":"mutable struct Cylinder{T} <: ConstrainedDynamics.Shape{T}\n\nA Cylinder along the z-axis.\n\nImportant attributes\n\nrh: The cylinder radius and height (vector).  \n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Sphere","category":"page"},{"location":"library/body/#ConstrainedDynamics.Sphere","page":"Bodies and Origin","title":"ConstrainedDynamics.Sphere","text":"mutable struct Sphere{T} <: ConstrainedDynamics.Shape{T}\n\nA Sphere.\n\nImportant attributes\n\nr: The sphere radius.  \n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Bodies and Origin","title":"Bodies and Origin","text":"Pyramid","category":"page"},{"location":"library/body/#ConstrainedDynamics.Pyramid","page":"Bodies and Origin","title":"ConstrainedDynamics.Pyramid","text":"mutable struct Pyramid{T} <: ConstrainedDynamics.Shape{T}\n\nA square Pyramid with a base in the x-y-plane.\n\nwh: The pyramid width and height (vector). \n\n\n\n\n\n","category":"type"}]
}
