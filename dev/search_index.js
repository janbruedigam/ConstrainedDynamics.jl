var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/code/#Mechanism-from-Code","page":"From Code","title":"Mechanism from Code","text":"","category":"section"},{"location":"gettingstarted/code/","page":"From Code","title":"From Code","text":"Besides parsing a URDF file, you can also code up your mechanism.","category":"page"},{"location":"gettingstarted/code/","page":"From Code","title":"From Code","text":"## Dynamics simulation\nusing ConstrainedDynamics\n\n# Origin\norigin = Origin{Float64}()\n\n# Links\nlink1 = Box(0.1, 0.1, 1, 1) # Box with length-x, length-y, length-z, and mass\nlink2 = Box(0.1, 0.1, 1, 1)\n\nlinks = [link1;link2]\n\n# Constraints\naxis = [1;0;0] # rotation axis\nconnection1 = [0;0;0.5] # connection points in body frame\nconnection2 = [0;0;-0.5]\njoint01 = EqualityConstraint(Revolute(origin, link1, axis; p2=connection1))\njoint12 = EqualityConstraint(Revolute(link1, link2, axis; p1=connection2, p2=connection1))\n\nconstraints = [joint01;joint12]\n\n# Mechanism\nmech = Mechanism(origin, links, constraints)\n\n# Set feasible initial configuration\nsetPosition!(origin, link1, p2 = connection1) # set link1 relative to origin\nsetPosition!(link1, link2, p1 = connection2, p2 = connection1, Δq = UnitQuaternion(RotX(pi/2))) # set link2 relative to link1 with an offset angle of pi/2\n\n# Simulate\nstorage = simulate!(mech, 10, record = true) # simulate mech for 10 seconds and record the result (will be stored in storage)\n\n## Visualization\nusing ConstrainedDynamicsVis \n\nvisualize(mech, storage) # visualize mech with the data in storage.\n ","category":"page"},{"location":"library/mechanism/#Mechanism","page":"Mechanism","title":"Mechanism","text":"","category":"section"},{"location":"library/mechanism/#Index","page":"Mechanism","title":"Index","text":"","category":"section"},{"location":"library/mechanism/","page":"Mechanism","title":"Mechanism","text":"Pages   = [\"library/mechanism.md\"]\nOrder   = [:type, :function]","category":"page"},{"location":"library/mechanism/#The-Mechanism-type","page":"Mechanism","title":"The Mechanism type","text":"","category":"section"},{"location":"library/mechanism/","page":"Mechanism","title":"Mechanism","text":"Mechanism","category":"page"},{"location":"library/mechanism/#ConstrainedDynamics.Mechanism","page":"Mechanism","title":"ConstrainedDynamics.Mechanism","text":"mutable struct Mechanism{T, Nn, Nb, Ne, Ni} <: ConstrainedDynamics.AbstractMechanism{T,Nn,Nb,Ne,Ni}\n\nA Mechanism contains the Origin, Bodys, and EqualityConstraints of a system and can be used for simulation. The time step Δt and gravity g can be specified.\n\n\n\n\n\n","category":"type"},{"location":"library/mechanism/#Functions","page":"Mechanism","title":"Functions","text":"","category":"section"},{"location":"library/mechanism/","page":"Mechanism","title":"Mechanism","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"mechanism.jl\"]","category":"page"},{"location":"gettingstarted/urdf/#Mechanism-from-URDF","page":"From URDF","title":"Mechanism from URDF","text":"","category":"section"},{"location":"gettingstarted/urdf/","page":"From URDF","title":"From URDF","text":"The easiest way to run a simulation is to parse a URDF file.","category":"page"},{"location":"gettingstarted/urdf/","page":"From URDF","title":"From URDF","text":"## Dynamics simulation\nusing ConstrainedDynamics\n\npath = \"path_to_file/doublependulum.urdf\"\nmech = Mechanism(path; Δt = 0.01)\nstorage = simulate!(mech, 10, record = true) # simulate mech for 10 seconds and record the result (will be stored in storage)\n\n## Visualization\nusing ConstrainedDynamicsVis \n\nvisualize(mech, storage) # visualize mech with the data in storage.\n ","category":"page"},{"location":"library/shape/#Shape","page":"Shape","title":"Shape","text":"","category":"section"},{"location":"library/shape/#Index","page":"Shape","title":"Index","text":"","category":"section"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Pages   = [\"library/shape.md\"]\nOrder   = [:type, :function]","category":"page"},{"location":"library/shape/#The-Shape-types","page":"Shape","title":"The Shape types","text":"","category":"section"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Shape","category":"page"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Mesh","category":"page"},{"location":"library/shape/#ConstrainedDynamics.Mesh","page":"Shape","title":"ConstrainedDynamics.Mesh","text":"mutable struct Mesh{T} <: ConstrainedDynamics.Shape{T}\n\nA Mesh can be used to visualize arbitrary geometries in a set color with a specification file at path. For .obj-files, the scale can be set (default = [1;1;1]).\n\n\n\n\n\n","category":"type"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Box","category":"page"},{"location":"library/shape/#ConstrainedDynamics.Box","page":"Shape","title":"ConstrainedDynamics.Box","text":"mutable struct Box{T} <: ConstrainedDynamics.Shape{T}\n\nA Box can be used to visualize boxes of size xyz in a set color.\n\n\n\n\n\n","category":"type"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Cylinder","category":"page"},{"location":"library/shape/#ConstrainedDynamics.Cylinder","page":"Shape","title":"ConstrainedDynamics.Cylinder","text":"mutable struct Cylinder{T} <: ConstrainedDynamics.Shape{T}\n\nA Cylinder can be used to visualize cylinders of size rh in a set color.\n\n\n\n\n\n","category":"type"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Sphere","category":"page"},{"location":"library/shape/#ConstrainedDynamics.Sphere","page":"Shape","title":"ConstrainedDynamics.Sphere","text":"mutable struct Sphere{T} <: ConstrainedDynamics.Shape{T}\n\nA Sphere can be used to visualize spheres of radius r in a set color.\n\n\n\n\n\n","category":"type"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Pyramid","category":"page"},{"location":"library/shape/#ConstrainedDynamics.Pyramid","page":"Shape","title":"ConstrainedDynamics.Pyramid","text":"mutable struct Pyramid{T} <: ConstrainedDynamics.Shape{T}\n\nA Pyramid can be used to visualize pyramids of size wh in a set color.\n\n\n\n\n\n","category":"type"},{"location":"library/shape/#Functions","page":"Shape","title":"Functions","text":"","category":"section"},{"location":"library/shape/","page":"Shape","title":"Shape","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"shape.jl\"]","category":"page"},{"location":"library/state/#State","page":"State","title":"State","text":"","category":"section"},{"location":"library/state/#Index","page":"State","title":"Index","text":"","category":"section"},{"location":"library/state/","page":"State","title":"State","text":"Pages   = [\"library/state.md\"]\nOrder   = [:type, :function]","category":"page"},{"location":"library/state/#The-State-type","page":"State","title":"The State type","text":"","category":"section"},{"location":"library/state/","page":"State","title":"State","text":"State","category":"page"},{"location":"library/state/#Functions","page":"State","title":"Functions","text":"","category":"section"},{"location":"library/state/","page":"State","title":"State","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"state.jl\"]","category":"page"},{"location":"library/equalityconstraint/#EqualityConstraint","page":"Constraint","title":"EqualityConstraint","text":"","category":"section"},{"location":"library/equalityconstraint/#Index","page":"Constraint","title":"Index","text":"","category":"section"},{"location":"library/equalityconstraint/","page":"Constraint","title":"Constraint","text":"Pages   = [\"library/equalityconstraint.md\"]\nOrder   = [:type, :function]","category":"page"},{"location":"library/equalityconstraint/#The-EqualityConstraint-type","page":"Constraint","title":"The EqualityConstraint type","text":"","category":"section"},{"location":"library/equalityconstraint/","page":"Constraint","title":"Constraint","text":"EqualityConstraint","category":"page"},{"location":"library/equalityconstraint/#ConstrainedDynamics.EqualityConstraint","page":"Constraint","title":"ConstrainedDynamics.EqualityConstraint","text":"mutable struct EqualityConstraint{T, N, Nc, Cs} <: ConstrainedDynamics.AbstractConstraint{T,N}\n\nAn EqualityConstraint is used to describe the kinematic relation between two or more Bodys. For referencing, each EqualityConstraint is assigned a unique id when added to a Mechanism. A name can also be set. Typically, an EqualityConstraint should not be created directly, but as a joint (see Joint).\n\n\n\n\n\n","category":"type"},{"location":"library/equalityconstraint/#Functions","page":"Constraint","title":"Functions","text":"","category":"section"},{"location":"library/equalityconstraint/","page":"Constraint","title":"Constraint","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"equalityconstraint.jl\"]","category":"page"},{"location":"#ConstrainedDynamics","page":"Home","title":"ConstrainedDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConstrainedDynamics is a rigid body dynamics package written in Julia. It uses maximal coordinates instead of minimal coordinates to represent the states of a mechanism. This parametrization can be advantageous when simulating structures with additional explicit constraints.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is largely built on StaticArrays and avoids allocations for improved performance. Convenience methods for setting up mechanical structures in maximal or minimal coordinates are provided and URDF parsing is also available. The provided examples should help with getting started with the package. ","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"body.md\",\n  \"shape.md\",\n  \"state.md\",\n  \"equalityconstraint.md\",\n  \"mechanism.md\",\n  \"interface.md\",\n  \"simulation.md\"]\nDepth = 2","category":"page"},{"location":"library/body/#Body-and-Origin","page":"Body","title":"Body and Origin","text":"","category":"section"},{"location":"library/body/#Index","page":"Body","title":"Index","text":"","category":"section"},{"location":"library/body/","page":"Body","title":"Body","text":"Pages   = [\"library/body.md\"]\nOrder   = [:type, :function]","category":"page"},{"location":"library/body/#The-Body-and-Origin-types","page":"Body","title":"The Body and Origin types","text":"","category":"section"},{"location":"library/body/","page":"Body","title":"Body","text":"Body","category":"page"},{"location":"library/body/#ConstrainedDynamics.Body","page":"Body","title":"ConstrainedDynamics.Body","text":"mutable struct Body{T} <: ConstrainedDynamics.AbstractBody{T}\n\nA Body is described by a mass m and inertia J. For referencing, each Body is assigned a unique id when added to a Mechanism. A name can also be set. The state of a Body contains position, orientation, and velocity information (stored as a State). For Visualization, a shape can be assigned to a Body or a Body can be directly created from a Shape. \n\n\n\n\n\n","category":"type"},{"location":"library/body/","page":"Body","title":"Body","text":"Origin","category":"page"},{"location":"library/body/#ConstrainedDynamics.Origin","page":"Body","title":"ConstrainedDynamics.Origin","text":"mutable struct Origin{T} <: ConstrainedDynamics.AbstractBody{T}\n\nThe Origin is the root of a mechanism. For referencing, the Origin is assigned a unique id when added to a Mechanism. A name can also be set. For Visualization, a shape can be assigned to the Origin. \n\n\n\n\n\n","category":"type"},{"location":"library/body/#Functions","page":"Body","title":"Functions","text":"","category":"section"},{"location":"library/body/","page":"Body","title":"Body","text":"Modules = [ConstrainedDynamics]\nOrder   = [:function]\nPages   = [\"body.jl\"]","category":"page"}]
}
